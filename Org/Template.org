# -*- mode:org; -*-

#+title:TITLE
#+subtitle:{{{version}}} {{{date}}}
#+author:AUTHOR
#+date:2020-06-14 03:08
#+macro:version Version 0.5.14
#+macro:upload-date (eval (current-time-string))
#+bucket:pinecone-forest

{{{version}}} {{{date}}}

#+texinfo:@insertcopying


* Readme
:PROPERTIES:
:unnumbered: t
:END:
- [[https://daringfireball.net/projects/markdown/][Markdown Home]]

- [[https://spec.commonmark.org/0.29/][CommonMark Spec]]

- [[https://guides.github.com/features/mastering-markdown/][Mastering Markdown]]

- [[https://github.github.com/gfm/][GitHub Flavored Markdown Spec]]

- [[https://help.github.com/en/github/writing-on-github][Writing on GitHub]]

- [[https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet][Markdown Cheatsheet]]

- [[https://guides.github.com/pdfs/markdown-cheatsheet-online.pdf][Markdown Syntax]]

- [[https://developer.github.com/v3/markdown/][GitHub REST API v3 --- Markdown]]


This Readme should be tangled and included in all git commits.	It’s purpose is
to provide an introduction to viewers of the source code on GitHub.

#+texinfo:@heading Using the ABSTRACT Entry

Each Readme should also provide an =ABSTRACT= entry for use by the ~sync~
command.  Each Org source file in a group of related ~.info~ blogs produces a
directory of linked HTML files via the ~make html~ command (which runs
~makeinfo --html <project>.texi~).  The directory of linked HTML files is
uploaded by the AWS ~make sync~ command into a separate directory of the chosen
AWS bucket for this group of related ~.info~ blogs.  Given a bucket name
~project~, and an ~.info~ blog named ~all-about-something~, with a version
number of ~v0.1.2~, the group of HTML files will be uploaded to an AWS bucket
that can be accessed like so:
: https://<project>.com/all-about-something-v0.1.2/

At the same time, the code running the ~make sync~ command will copy the text
from the =ABSTRACT= section of the Readme and create a directory at the domain
level of the AWS bucket linking to the current version of the ~index.html~ of
this subproject.  The =ABSTRACT= entry will provide some context in the
directory at the domain level, allowing the viewer to peruse the list of
~.info~ blogs and choose one based on its context.  In other words, by opening
the project domain at:
: https://<project>.com
the user will see a list of all related subprojects which link directly to the
most recently uploaded version.

#+name:project-readme
#+header: :tangle README.md
#+begin_src markdown
# TITLE
## Subtitle
## Author
## Date
## Version
# ABSTRACT
This is the Org Template file.	It is the parent of all other Org Info blogs,
and provides the source code for processing them in various different ways.
# INTRODUCTION
# CHAPTER
## Section
### Subsection
#+end_src

* Introduction
:PROPERTIES:
:unnumbered: t
:END:
** TODO Ideas on how to make this a better system
*** TODO Install major dependencies
[2020-02-14 Fri 10:12]
- [ ] like ~aws2~
- [ ] Org-mode > 9.1.9

*** TODO Get rid of hard-coded directories
- [ ] ~create-script~
  [2020-02-14 Fri 09:45]

  This script places itself inside a ~bin/~ directory so it can be found by
  searching $PATH.  This can be accomplished by creating an environment
  variable; I need to come up with a good domain name for this system first.
  How about =SyncOrg=?	So the environment variable would be =SYNC_ORG_BIN=.  A
  possible value would =~/Dev/bin= or =/usr/local/dev/bin=, depending on the
  system.

*** TODO Add check for existence of environment variables
[2020-02-14 Fri 09:57]
- [ ] it appears environment variables do not expand inside header lines? Check
  this.
- [ ] if environment variables do not expand, then need to provide a script to
  update them upon installation
- [ ] such as =SYNC_ORG_BIN=

*** DONE Update Date

- State "DONE"	     from "TODO"       [2020-03-02 Mon 21:12]
- State "TODO"	     from	       [2020-03-01 Sun 10:36] \\
  When creating a new project from this template, update the #+date: to
  the current day and time instead of leaving it to when this template
  was last updated.

*** TODO Make Update independent of the project

- State "TODO"	     from	       [2020-03-01 Sun 14:07] \\
  I just tried to update a project, but the command AWS :=: aws2 did not
  work because it has changed to aws version 2.	 If the update program
  had been independent and based upon Template's most recent code, then
  that would not have happened.	 Who knows what the next problem will be
  causing the project's out-of-date code to fail to update.
*** DONE Make adding git repo an option
- State "DONE"	     from	       [2020-03-02 Mon 21:13]
*** TODO Default macros
    - State "TODO"       from              [2020-04-01 Wed 10:49] \\
      Default macros do not get expanded or in some cases even recognized.
      Is this a bug or am I doing something wrong.  User-defined macros
      work.
*** TODO Dependencies
:LOGBOOK:
- State "TODO"       from              [2020-06-09 Tue 23:36] \\
  Provide function to collect all dependencies and list; or perhaps test
:END:
* Chapter

* Build Tools
:PROPERTIES:
:appendix: t
:custom_id: build-tools
:from-file: Template
:END:
** Makefile					:dependencies:env_vars:perl:
:PROPERTIES:
:appendix: t
:dependency1: make
:dependency2.0: AWS User account at https://aws.amazon.com
:dependency2.1: AWS cli v2 in PATH https://docs.aws.amazon.com/cli/index.html
:dependency2.2: See how to Install AWS CLI v2 at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html
:dependency2.3: aws credentials: access token and secret access token stored in ~/.aws/credentials
:dependency2.4: AWS S3 buckets set up for serving a static web page
:dependency3: GitHub Account with personal access token stored in GITHUB_TOKEN
:dependency4: texinfo @6.7._
:dependency5: Emacs, Org-mode, Babel language 'shell' enabled
:env_var1: SYNC_ORG_TEMPLATE: holds the full path to this Template.org file
:env_var2: GITHUB_TOKEN: holds the GitHub personal access token
:env_var3: EDITOR: must hold a reference to a working emacsclient server
:env_var4: COLORS
:END:

#+name:Makefile
#+header: :tangle Makefile
#+begin_src makefile

###############################################################################
### USER-DEPENDENT VARIABLES
### USE ENVIRONMENT VARIABLES WHENEVER POSSIBLE
### NEED ~/.aws/credentials installed

# The absolute path to this Template file
TEMPLATE := $(SYNC_ORG_TEMPLATE)

# Use emacsclient as $EDITOR; make sure it is set in .bash_profile
EDITOR	  := $(EDITOR)

# User’s personal GitHub token for authentication to GitHub
# DO NOT HARD-CODE THIS VALUE
GITHUB_TOKEN := $(GITHUB_TOKEN)

### END OF USER-DEPENDENT VARIABLES
###############################################################################
### MAKE-GENERATED VARIABLES

### PROJ AND ORG
# ORG is the name of this Org file
# PROJ is the project name---this Org file without extension.

### NOTE: there can be only one Org file in the project directory;
# so far this has not been a problem, but it might be.

ORG  := $(shell ls *.org)
PROJ := $(basename $(ORG))

### NOTE: S is needed only for the Template file because of the way it is nested
# one level deep in the Templates GitHub repo, which uses the plural form
# of Templates, whereas this file uses the singular form, Template.  So when
# the homepage link is updated, the curl command must be told to use the plural
# form.	 This is obviously a hack only for my own use and can be removed once
# I clean up this anomaly.

ifeq ($(PROJ),$(basename $(notdir $(TEMPLATE))))
S := s
endif

# The AWS S3 bucket to use to store the html source file; it is found at the
# key #+bucket towards the beginning of the file
S3_BUCKET := s3://$(shell $(EDITOR) --eval \
	'(with-current-buffer (find-file-noselect "$(ORG)") \
		(save-excursion \
		(goto-char (point-min)) \
		(re-search-forward "^\#[+]bucket:\\(.*\\)$$") \
		(match-string-no-properties 1)))').com

# The AWS Command Line Interface (AWS CLI) is an open source tool
# that enables you to interact with AWS services using commands in
# your command-line shell.
AWS := aws
S3  := $(AWS) s3

# The AWS region of choice; this can also be in .aws/config
REGION := --region us-west-2

### DIR, SRC
# DIR is the .info name found at '#+texinfo_filename:<DIR>.info' (at
# the bottom of this file in the export configuration settings)
# without its extension, used as the INFO filename and the name of the
# HTML export directory; this code uses the lowercased PROJ name if
# there is no '#+texinfo_filename'.
# SRC is HTML directory based upon the DIR name

# NOTE: 're-search-forward' will either return an error or 'nil',
# depending on the value of the third argument, if the search fails.
# If it returns an error, then that error shows up in the shell
# output.  It might be advantageous to let it so you are aware that
# there is no 'texinfo_filename', but for now it is set to return
# 'nil' on failure, and then assign the backup value.

DIR := $(shell $(EDITOR) --eval \
	'(with-current-buffer (find-file-noselect "$(ORG)") \
		(save-excursion \
		(goto-char (point-min)) \
		(re-search-forward "^\#[+]\\(?:texinfo_filename\\|TEXINFO_FILENAME\\):\\(.*\\).info$$" nil t) \
		(match-string-no-properties 1)))')
ifeq ($(DIR),nil)
	DIR := $(shell echo $(PROJ) | tr "[:upper:]" "[:lower:]")
endif

SRC := $(DIR)/

### VERS: v1.2.34/
# VERS is the version number of this Org document.
# When sync is run after the version number has been updated, then VERS
# picks up the newly-changed value.  VERS used to be staticly imbedded
# when the Makefile was tangled, but it needs to be dynamic for
# development.

# QUERY: should this number be formatted like this, or should it be just the numbers?
# The reason it includes them is the S3PROJ obtains the name from the S3 bucket, and
# it includes them.  But it only includes them because I have made it so.  Not a good
# reason just by itself.  The ending slash is not actually a part of the version, but
# comes from the way the 'aws2 ls' command returns its values.	So VERS should probably
# not include the trailing slash, although it doesn’t hurt anything.

VERS := v$(shell $(EDITOR) --eval \
	'(with-current-buffer (find-file-noselect "$(ORG)") \
		(save-excursion \
		(goto-char (point-min)) \
		(re-search-forward "^\#[+]\\(?:macro\\|MACRO\\):version Version \\(\\(?:[[:digit:]]+[.]?\\)\\{3\\}\\)") \
		(match-string-no-properties 1)))')/

### AWS
# PROJ_LIST contains the list of projects currently uploaded to
# the S3 bucket; each item contains the name of the project and its
# current version.

PROJ_LIST := $(strip $(filter-out PRE, $(shell $(AWS) s3 ls $(S3_BUCKET))))

### PROJ_LIST
# The name of the current project as obtained from S3: 'proj-v1.2.34/'
# If there is no current project in the S3 bucket, then assign a value equal to
# the Org project and version instead.
### S3VERS
# The version of this project currently installed in the S3 bucket: 'v1.2.34/'
# If there is no current version in the S3 bucket, then assign the version from
# this Org file instead.

S3PROJ := $(filter $(DIR)%,$(PROJ_LIST))
ifeq ($(S3PROJ),$(empty))
	S3PROJ := $(DIR)-$(VERS)
endif

S3VERS := $(subst $(DIR)-,,$(filter $(DIR)%, $(PROJ_LIST)))
ifeq ($(S3VERS), $(empty))
	S3VERS := $(VERS)
endif

### GITHUB
# USER is the current user's GitHub login name.

# The user name used to be statically embedded into the Makefile
# during tangle, but in an effort to make the Makefile dynamically
# indepedent, dynamic code has replaced the static code.  The code
# that placed the static name in the Makefile was a 'node' script that
# ran in a separate Org process during tangle.	An unfortunate fact of
# 'make' is that 'make' strips the quote marks from the string
# obtained from the 'curl' command when the 'make shell' command
# returns the string.	 This makes the string malformed JSON and
# unparsable by most JSON parsers, including 'node’.	However,
# 'perl'’s core module JSON::PP (but not JSON::XS) has facilities to
# parse very malformed JSON strings.	Therefore, this dynamic code
# uses 'perl' and the core module JSON::PP to parse the 'curl' string
# into a 'perl' JSON object which can return the login name.	This
# code should work with any version of 'perl' without having to
# install any modules.

USER := $(shell \
	  curl -sH "Authorization: token $(GITHUB_TOKEN)" https://api.github.com/user \
	  | \
	  perl -MJSON::PP -e \
	      '$$/ = ""; \
	       my $$json = JSON::PP->new->loose->allow_barekey->decode(<STDIN>); \
	       print $$json->{login};' \
	  )

### TOOLS & RESOURCES
# tools is a directory holding tangled scripts, such as cmprpl
TOOLS	:= tools
CMPRPL	:= $(TOOLS)/cmprpl
SAVE	:= resources

### TEXINFO
TEXI	:= $(PROJ).texi
INFO	:= $(DIR).info
PDF	:= $(PROJ).pdf
INDEX	:= index.html
HTML	:= $(DIR)/$(INDEX)
DIR_OLD	:= $(DIR)-old

### AWS S3
DST_OLD	:= $(S3_BUCKET)/$(S3PROJ)
DST_NEW	:= $(S3_BUCKET)/$(DIR)-$(VERS)
EXCL_INCL:= --exclude "*" --include "*.html"
GRANTS	:= --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
S3SYNC	:= $(S3) sync --delete $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
S3MOVE	:= $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)
S3COPY  := $(S3) cp $(INDEX) $(S3_BUCKET) $(REGION) $(GRANTS)

###############################################################################

default: check texi info html pdf

PHONY: default all check values boot \
	  texi info html pdf \
	  open-org open-texi open-html open-pdf \
	  clean dist-clean wiped-clean \
	  help sync update \
	  install-aws-cli \
	  index-html upload-index-html

values: check
	  @printf "$${BLUE}Values...$${CLEAR}\n"
	  @echo TEMPLATE:	$(TEMPLATE)
	  @echo EDITOR:		$(EDITOR)
	  @echo USER:		$(USER)
	  @echo ORG:		$(ORG)
	  @echo PROJ:		$(PROJ) $S
	  @echo S3_BUCKET	$(S3_BUCKET)
	  @echo VERS:		$(VERS)
	  @echo S3PROJ:		$(S3PROJ)
	  @echo S3VERS:		$(S3VERS)
	  @echo DIR:		$(DIR)
	  @echo DIR_OLD:	$(DIR_OLD)
	  @echo SRC:		$(SRC)
	  @echo DST_OLD:	$(DST_OLD)
	  @echo DST_NEW:	$(DST_NEW)
	  @echo PROJ_LIST:	$(PROJ_LIST)

check:
	  @printf "$${BLUE}Checking dependencies...$${CLEAR}\n"
	  @[[ -z $${AWS_S3_BUCKET} ]] && \
	     { printf "$${RED}\$$AWS_S3_BUCKET $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${CYAN}AWS_S3_BUCKET: $${GREEN}$${AWS_S3_BUCKET}$${CLEAR}\n";
	  @[[ -z $${GITHUB_TOKEN} ]] && \
	     { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${CYAN}GITHUB_TOKEN: $${GREEN}SET$${CLEAR}\n";
	  @[[ (-d ~/.aws) && (-f ~/.aws/credentials) && (-f ~/.aws/config) ]] && \
	     printf "$${CYAN}AWS credentials and config: $${GREEN}SET$${CLEAR}\n" || \
	     { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }

	  @[[ "$(shell $(EDITOR) --eval '(member (quote texinfo) org-export-backends)')" = "(texinfo)" ]] && \
		printf "$${CYAN}Texinfo backend: $${GREEN}INSTALLED.$${CLEAR}\n" || \
		{ printf "$${YELLOW}Texinfo backend:$${CLEAR} $${RED}NOT INSTALLED; it must be installed.$${CLEAR}\n"; exit 1; }

	  @[[ $(shell $(EDITOR) --eval '(symbol-value org-confirm-babel-evaluate)') == "t" ]] && \
		{ printf "$${YELLOW}org-confirm-babel-evaluate:$${CLEAR} $${RED}T; set to NIL.$${CLEAR}\n"; exit 1; } || \
		printf "$${CYAN}org-confirm-babel-evaluate: $${GREEN}OFF.$${CLEAR}\n\n"

open-org: $(ORG)
	  @$(EDITOR) -n $(ORG)
$(ORG):
	  @echo 'THERE IS NO $(ORG) FILE!!!'
	  exit 1

texi: $(TEXI)
$(TEXI): $(ORG)
	 @echo Making TEXI...
	 @$(EDITOR) -u --eval \
		"(with-current-buffer (find-file-noselect \"$(ORG)\" t) \
			(save-excursion \
			(org-texinfo-export-to-texinfo)))"
	 @echo Done making TEXI.
open-texi: texi
	 @$(EDITOR) $(TEXI)

info: $(INFO)
$(INFO): $(TEXI)
	 @echo Making INFO...
	 @makeinfo $(TEXI)
	 @echo Done making INFO.
open-info: info
	 @$(EDITOR) $(INFO)

html: $(HTML)
$(HTML): $(TEXI)
	 @echo Making HTML INFO..
	 @makeinfo --html -o $(DIR) $(TEXI)
	 @echo Done making HTML.
	 $(CMPRPL) $(DIR) $(DIR_OLD)
open-html: html
	 @open $(HTML)

# If pdftexi2dvi produces an error, it may still produce a viable PDF;
# therefore, use --tidy.  If it produces an error, try to link the PDF;
# if it does not produce an error, the PDF will be added to the top dir
# and there will be no attempt to link.
pdf: $(PDF)
$(PDF): $(TEXI)
	 @echo Making PDF INFO...
	 @-pdftexi2dvi --quiet --build=tidy $(TEXI) || ln -s $(PROJ).t2d/pdf/build/$(PDF) $(PDF)
	 @echo Done making PDF.
open-pdf: pdf
	 @open $(PDF)

sync:	$(HTML)
	@echo Syncing version $(VERS) onto $(S3VERS)...
	$(S3SYNC)
	@echo Done syncing.
	[[ $(VERS) != $(S3VERS) ]] && { echo Moving...; $(S3MOVE); echo Done moving.;  make homepage; } || :

# This is a target-specific variable for updating the “description”
# key on the GitHub repo page with the current version number.	It
# first makes a curl call to the GitHub project repo, finds the
# “description” line, pulls out the description only (leaving the old
# version) and then prints the value with the current version number.
# This value is used by the “homepage:” target in the PATCH call.
# This method is arguably harder to code but faster to run than using
# Perl with the JSON::PP module.

homepage: description = $(shell \
	curl -s \
		-H "Authorization: token $(GITHUB_TOKEN)" \
		https://api.github.com/repos/$(USER)/$(PROJ)$S | \
		(perl -ne 'if (/^\s*\"description\":\s*\"(.*): v(?:(?:[[:digit:]]+[.]?){3})/) {print $$1}'))

### NOTE the use of the S variable at the end of PROJ; this is to handle
# the singular case of the GitHub repo using the plural form, Templates
# whereas the the Template.org file uses the singular form.
homepage: $(ORG) upload-index-html
	  @echo Updating homepage...
	  @echo $(description)
	  @curl -i \
		-H "Authorization: token $(GITHUB_TOKEN)" \
		-H "Content-Type: application/json" \
		-X PATCH \
		-d '{"homepage":"https://$(AWS_S3_BUCKET)/$(DIR)-'$(VERS)'",\
		     "description":"$(description): '$(VERS)'"}' \
		https://api.github.com/repos/$(USER)/$(PROJ)$S
	  @echo Done updating homepage.

index-html: $(INDEX)
$(INDEX): $(ORG)
	@echo making index.html...
	$(EDITOR) --eval \
	"(with-current-buffer (find-file-noselect \"$(ORG)\") \
		(org-link-search \"#project-index-title\") \
		(org-export-to-file (quote html) \"index.html\" nil t))"
	@echo Done making index.html.

upload-index-html: $(INDEX)
	 @echo Uploading index.html...
	 $(S3COPY)
	 @echo Done uploading index.html

update: $(ORG)
	@echo Updating $(ORG)...
	$(EDITOR) -u --eval '\
	(progn \
	     (find-file "$(TEMPLATE)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-copy-subtree) \
	     (kill-buffer) \
	     (find-file "$(ORG)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-yank) \
	     (org-cut-subtree) \
	     (save-buffer) \
	     (kill-buffer) \
	     (setq org-confirm-babel-evaluate nil) \
	     (org-babel-tangle-file "$(ORG)"))'
	 @echo Done updating $(ORG).

install-aws-cli:
	  curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg" && \
	  sudo installer -pkg AWSCLIV2.pkg -target / && \
	  which aws && aws --version
	  rm -rf AWSCLIV2.pkg

clean:
	  -rm *~
	  -for file in *.??*; \
	  do \
		  ext=$${file#$(PROJ).}; \
		  [[ ! $${ext} =~ org|texi|info|pdf|html ]] && rm -rv $${file}; \
	  done

dist-clean: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	  -for dir in *; \
	  do \
		  [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		  rm -vr $$dir; \
	  done

wipe-clean: dist-clean
	  -rm -rf Makefile Readme.md $(DIR_OLD)
	  git checkout Makefile README.md

help:
	  @echo '"make default" makes the .texi file, the .info file, \
	  the html files, and the .pdf file.'
	  @echo

	  @echo '"make check" checks for prerequistes'
	  @echo '"make values" runs check and prints variable values'
	  @echo

	  @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	  you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make install-aws-cli" installs the "aws cli v2" command-line tools'
	  @echo 'You also need to run "aws configure" and supply your Access Key and Secret Access Key'

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make dist-clean" cleans, removes the html distribution, \
	  and removes the build directory'
	  @echo '"make wipe-clean" wipes clean the directory, including old directories'
	  @echo '"make boot" tangles all of the files in Template'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.	 This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=.  It also makes sure there is a
Makefile on an initial export.	The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The AWS ~sync~ command relies upon time stamps to determine whether two
programs are identical or not, as well as content.  If two otherwise identical
files have different time stamps, ~sync~ will assume they are different and
will process the newer.	 However, the ~texinfo~ ~makeinfo --html~ command
produces all new files even if some files (or most files) remain unchanged.
This means that all files will be uploaded to the AWS S3 bucket on every
iteration, even though the majority of the files are actually unchanged.

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: =$DIR_NEW=.  If
it doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, =$DIR_OLD=.	 If one
doesn’t, then one is created by copying the current new directory.  This
provides a baseline for comparisons going forward.  The program exits at that
point.	It is very important that the =$DIR_OLD= directory not be deleted going
forward.

Given that =$DIR_OLD= exists, the program then loops through all files in
=$DIR_NEW= and compares them to the files in =$DIR_OLD=.  If the files are
identical, the =$DIR_OLD= file replaces the =$DIR_NEW= file while retaining the
old time stamp (using the ~-p~ option of ~cp~.	If a file is different, then
the =$DIR_NEW= file replaces the =$DIR_OLD= file, thus giving it updated
content and an updated time stamp.  If the file does not exist in the
=$DIR_OLD= directory, then it is added.

The program then loops through all of the files in the old directory and deletes
any that do not exist in the new directory.  Now both directories should be in
sync.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      if [[ -e $oldfile ]]
      then
	 if cmp -s $newfile $oldfile
	 then
	     printf "${GREEN}copying OLD to NEW${CLEAR}: "
	     cp -vp $oldfile $newfile
	 else
	     printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	     cp -vp $newfile $oldfile
	 fi
      else
	  printf "${BLUE}creating NEW in OLD${CLEAR}: "
	  cp -vp $newfile $oldfile
      fi
  done

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ ! -e $newfile ]]
      then
	  printf "${RED}removing OLD${CLEAR}: "
	  rm -v $oldfile
      fi
  done
#+end_src


** Update Utility Commands
*** Get Parsed Org Tree
This function looks for an Org file in the present working directory, and if it
finds one returns a parsed tree using ~org-element-parse-buffer~.  It returns
=nil= if there is no Org file or if the found file is not in ~org-mode~.

#+name:get-parsed-org-tree
#+header: :results silent
#+begin_src emacs-lisp
(defun get-parsed-org-tree (&optional org-dir)
  "This function takes an optional directory name, changes to
that directory if given, otherwise uses the pwd, and finds an Org
file and returns its parsed tree, or nil if none found."
  (when org-dir
      (cd (file-name-as-directory org-dir)))
  (let ((buf (car-safe (find-file-noselect "*.org" nil nil t))))
    (if buf
	(with-current-buffer buf (org-element-parse-buffer))
      nil)))
#+end_src
*** Check for CID
This code checks whether an Org file contains a =custom_id= of a particular
value.  It accepts a ~cid-value~ and an optional directory.  If the directory
is not given, then it defaults to the current directory.  If throws an error if
the directory does not exist.  It returns =nil= if the given directory does not
contain an Org file.  It returns =t= if the Org file contains a node property
of =custom_id= and value ~cid-value~, or =nil= if not.  It uses
~get-parsed-org-tree~.

#+name:org-tree-cid-p
#+header: :results silent
#+begin_src emacs-lisp
(defun org-tree-cid-p (cid-value &optional org-dir)
  "Check whether an org file contains a custom_id of CID"
  (let ((tree (get-parsed-org-tree org-dir)))
    (car (org-element-map tree 'property-drawer
	   (lambda (pd) (org-element-map (org-element-contents pd) 'node-property
			  (lambda (np)
			    (and
			     (string= "custom_id" (org-element-property :key np))
			     (string= cid-value (org-element-property :value np))))))
	   nil t))))
#+end_src

#+name:run-org-tree-cid-p
#+header: :var cid="build-tools"
#+header: :var dir="~/Dev/Emacs/MasteringEmacs"
#+header: :var gpot=get-parsed-org-tree()
#+header: :var otcp=org-tree-cid-p()
#+header: :results value
#+header: :eval never-export
#+begin_src emacs-lisp
(org-tree-cid-p cid dir)
#+end_src

#+call: run-org-tree-cid-p(dir="~/Dev/Emacs/MasteringEmacs")

#+RESULTS:
: t

*** Add Bucket
This command utility takes two arguments:
1. The name of an Org file (e.g., "MasteringEmacs.org"); and
2. The name of an AWS S3 bucket


It checks whether the Org file in the present working directory has a
"#+bucket: keyword". If it does, then it simply returns nil. If it does not,
then it adds that bucket name as a keyword (e.g. "#+bucket:pinecone-forest") to
the Org file right after where the =version= macro is located, and saves the
file. It returns a message upon succuess.

#+name:add-bucket-fn
#+header: :eval never-export
#+header: :var parsed-tree=get-parsed-org-tree()
#+begin_src emacs-lisp
  ;;; Add a keyword named 'bucket' just after the version macro.
  ;;; This function should be run from within the directory containing the Org file.
  (defun add-bucket (s3-bucket)
    "Add the name of the associated AWS S3 bucket to an Org templated file in the PWD."
    (with-current-buffer (car (find-file-noselect "*.org" nil nil t))
      (goto-char (point-min))
      (let* ((tree parsed-tree)
	     ;; find the beginning position of the first headline to act as a limit
	     (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
	;; Check for the presence of a bucket keyword before the first headline
	(unless (re-search-forward "^#\\+bucket:" hl1 t)
	  ;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	  (org-element-map tree (quote keyword)
	    (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				    (string-match-p "version" (org-element-property :value kw)))
			   ;; return the end position of the MACRO; subtract an empty line if there is one
			   (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			   (insert "#+bucket:" s3-bucket)
			   (newline)
			   (basic-save-buffer)
			   (message (format "Added bucket %s" s3-bucket))))
	    nil t)))))
#+end_src
** Bucket Index HTML
The bucket should contain a master ~index.html~ file that links to each of the
individual project ~index.html~ files.  The master ~index.html~ file will be
placed at the root of the bucket, ~https://<bucket-name>.com/~, and the bucket
must be set up to serve this ~index.html~ when the user hits the root.

*** Get Bucket Name
 This code searches for the keyword-value pair =bucket:<BUCKET-NAME>= that
 should be located towards the beginning of the file, and returns the value
 =BUCKET-NAME= or nil if not found.

#+name: get-bucket-name
#+header: :results value
#+begin_src emacs-lisp
   (save-excursion
     (goto-char (point-min))
     (re-search-forward "^#\\+bucket:\\s*?\\(.*\\)$" nil t)
     (match-string-no-properties 1))
#+end_src

For some reason, ~get-bucket-name~ does not work when called from the headline
[[#project-index-links][=Links for bucket=]] below when creating =index.html=, even if it returns as
~(prin1 ...)~ and is set up to ~:return output~; the call receives =nil=. The
following code from ~bucket-name~, however, works. I don't know why.

#+name: bucket-name
#+header: :results output
#+header: :var bucket-name=get-bucket-name()
#+begin_src emacs-lisp
(prin1 bucket-name)
#+end_src

*** Bucket HTTPS URL
This code calls ~get-bucket-name~ and returns the value returned as a URL string or
nil.

#+name: bucket-https-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "https://" b ".com")
#+end_src

*** S3 Bucket URL
This code calls ~get-bucket-name~ and returns the AWS S3 bucket url.

#+name: s3-bucket-url
#+header: :results value
#+header: :var b=get-bucket-name()
#+begin_src emacs-lisp
(concat "s3://" b ".com")
#+end_src

*** Bucket Projects List
This code uses the ~s3-bucket-url~ result to obtain the list of projects in the
bucket.  It does this by calling the AWS S3 high-level command ~ls~ and then
removing the =PRE= string in each result.  The result that is returned is a
single string that can be separated into individual links by breaking the
string on spaces.

#+name: bucket-projects-list
#+header: :results output
#+header: :var bucket=s3-bucket-url()
#+begin_src sh
/usr/local/bin/aws s3 ls ${bucket} | sed -ne 's/^.*PRE //p'
#+end_src

*** Bucket Project Links
This code uses the result from ~bucket-projects-list~ to create an unordered
list of links written to bucket projects, written in Org-mode syntax. It is
executed by a =#+call:= in [[*Bucket Index][*Bucket Index]] during an HTML export of that subtree
to a file called =index.html=.

#+name: bucket-project-links
#+header: :var b-url=bucket-https-url()
#+header: :var projects=bucket-projects-list()
#+header: :results output raw
#+begin_src emacs-lisp
(seq-do (lambda (u) (princ (format "- [[%s/%sindex.html][~%s~]]
" b-url u u))) (split-string projects))
#+end_src

*** Bucket Index
    :PROPERTIES:
    :custom_id: project-index-title
    :export_file_name: index.html
    :export_subtitle: {{{version}}} created {{{upload-date}}}
    :END:
#+html_doctype: html5
#+options: toc:nil html5-fancy:t

#+html: <hr>

**** Links for bucket call_bucket-name()
     :PROPERTIES:
     :unnumbered: t
     :custom_id: project-index-links
     :END:

#+call: bucket-project-links()
** Samples
#+begin_comment
(cd "~/Dev/Emacs/MasteringEmacs/")
"/Users/pine/Dev/Emacs/MasteringEmacs/"

(defun add-bucket (org bucket)
  "Add a bucket keyword BUCKET to the org file ORG."
  (interactive "fFile: \nsBUCKET: ")
  (with-current-buffer (find-file-noselect org)
    (let* ((tree (org-element-parse-buffer))
	   (ins (car (org-element-map tree (quote section)
		 (lambda (s)
		   (org-element-map s (quote keyword)
		     (lambda (kw) (when (equal "MACRO" (org-element-property :key kw)) (1- (org-element-property :end kw))))
		     nil nil :keyword))
		 nil t nil nil))))
      (goto-char ins)
      (insert (format "#+bucket:%s\n" bucket))
      ())))

(add-bucket "MasteringEmacs.org" "pinecone-forest")
nil

(defun hl-region (raw-hl)
  "Obtain the begin and end positions for a headline."
  (with-current-buffer (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
    (let* ((tree (get-parsed-tree))
	   (hl (car-safe (org-element-map tree 'headline
			   (lambda (hl) (when
					    (string= raw-hl
						     (org-element-property :raw-value hl))
					  (org-element-context)))
			   nil nil t))))
      (cons
       (org-element-property :begin hl)
       (org-element-property :end hl))
      )))

(hl-region "Build Tools")

(4888 . 29646)

(defun get-hl-with-prop (org-dir hl-prop)
  "Given a directory containing an Org template file and a custom_id property name, return the headline containing that custom_id, or nil if none."
  (progn
    (cd org-dir)
    (let ((org-buf (car-safe (find-file-noselect "*.org" nil nil t))))
      (if org-buf
	  (with-current-buffer org-buf
	    (let ((tree (org-element-parse-buffer)))
	      (org-element-map tree 'headline
		(lambda (hl)
		  (let ((cid (org-element-property :CUSTOM_ID hl)))
		    (when (string= hl-prop cid)
		      (and
		       (message (format "Found the headline %s containing property %s." (org-element-property :raw-value hl) hl-prop))
		       hl))))
		nil t)))
	(and
	 (message (format "The directory %s does not contain an Org file." org-dir))
	 nil)))))

(get-hl-with-prop "~/Dev/Templates/Org" "build-tools")

(headline (:raw-value "Build Tools" :begin 4888 :end 29646 :pre-blank 0 :contents-begin 4902 :contents-end 29645 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 1 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 4888 :FROM-FILE "Template" :CUSTOM_ID "build-tools" :APPENDIX "t" :title "Build Tools"))









;;; Add a keyword named 'bucket' just after the version macro.
;;; This function should be run from within the directory containing the Org file.
(defun add-bucket (org-file s3-bucket)
  "Add the name of the associated AWS S3 bucket to an Org templated file."
  (with-current-buffer (find-file-noselect org-file)
    (goto-char (point-min))
    (let* ((tree (org-element-parse-buffer))
	   ;; find the beginning position of the first headline to act as a limit
	   (hl1 (org-element-map tree (quote headline) (lambda (hl) (org-element-property :begin hl)) nil t)))
      ;; Check for the presence of a bucket keyword before the first headline
      (unless (re-search-forward "^#\\+bucket:" hl1 t)
	;; If no bucket keyword is found, search for a keyword MACRO with the value 'version'
	(org-element-map tree (quote keyword)
	  (lambda (kw) (when (and (string= "MACRO" (org-element-property :key kw))
				  (string-match-p "version" (org-element-property :value kw)))
			 ;; return the end position of the MACRO; subtract an empty line if there is one
			 (goto-char (- (org-element-property :end kw) (org-element-property :post-blank kw)))
			 (insert "#+bucket:" s3-bucket)
			 (newline)
			 (basic-save-buffer)
			 (message (format "Added bucket %s" s3-bucket))))
	  nil t)))))

(add-bucket "MasteringEmacs.org" "pinecone-forest.com")
nil

"Added bucket pinecone-forest.com"









(keyword (:key "MACRO" :value "version Version 0.0.108" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...))
("TITLE" "SUBTITLE" "AUTHOR" "DATE" "MACRO" "TEXINFO" "TEXINFO" "CINDEX" "CINDEX" "CINDEX" "CINDEX" "CINDEX" ...)







((keyword (:key "MACRO" :value "version Version 0.0.107" :begin 148 :end 181 :post-blank 1 :post-affiliated 148 ...)))
#+end_comment

* Build Scripts
** Create Script					      :dependencies:
:PROPERTIES:
:dependency1: "${DEV}/bin/org-template"
:dependency2: "cp -v ${DEV}/Templates/Org/Template.org "$1/$1.org
:dependency3: "COLORS from profile"
:dependency4: tree
:dependency5: git
:END:
This code is a script file to create a new project from this template.	It is
called from the command line as ~org-template <project> [<author>]~.  It takes
one required, and up to two optional arguments.	 The required argument is the
name of the project.  One optional argument is the name of the author.	The
other optional argument is the term =git=, meaning to initialize a =git=
repository for the project.  Here are the steps it takes:

1. It creates a new directory in the current working directory using the
   =project= argument.

2. It copies this template into it as a new Org file using, again, the name
   of the project.

3. It then updates the title to the project name, and optionally the author,
   using the =author= argument if it was given.

4. It then deletes this script from the new Org project file.

5. It then tangles the ~README.md~ and the ~tools/cmprpl~ files into the
   project.

6. If the term ='git'= is supplied, it initializes a new Git repository,
   creates a basic ~.gitignore~ file in it, adds the Org file and the
   ~README.md~ file and makes an initial Git commit.

7. Finally, it prints an outline of the project’s structure using the ~tree~
   command.


#+caption:Create Script
#+name:create-script
#+header: :mkdirp yes
#+header: :tangle /usr/local/dev/bin/org-template
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh -n
  # $1 :=: Title
  [[ ($# -ge 1) && ($# -le 3) ]] || {
  printf "${RED}ERROR: ${YELLOW}\'org-template ${RED}<TITLE>${YELLOW} [<AUTHOR>] ['git']\'${CLEAR}\n"
	exit 1
  }
  printf "${PURPLE}"
  read -n 1 -p "Create new directory '$1' (y/n) ?"
  printf "${CLEAR}\n\n"
  [[ $REPLY =~ [yY] ]] && printf "${GREEN}" || exit 0

  mkdir -v "$1"
  printf "copy "
  cp -v ${SYNC_ORG_TEMPLATE} "$1/$1.org"
  printf "${CLEAR}\n"

  sed -i '' -Ee '/^\#\+(title|TITLE):/ s/TITLE/'"$1"'/' \
		-Ee '/^\#\+(date|DATE):\s*(.*)$/ s/$2/$(date '"+%F %R"')/' \
		-Ee '/^\#\+(macro|MACRO):version Version/ s/[[:digit:].]+/0.0.0/' \
		-Ee '/^\#\+(texinfo_printed_title|TEXINFO_PRINTED_TITLE):/ s/PRINTED TITLE/'"$1"'/' \
		"$1/$1.org"
  [[ $# -ge 2 ]] && \
      sed -i '' -Ee '/^\#\+(author|AUTHOR):/ s/AUTHOR/'"$2"'/' "$1/$1.org"

  printf "${CYAN}"
  ${EDITOR} --eval \
    '(save-current-buffer
       (set-buffer (find-file-noselect '\"$1/$1.org\"'))
       (search-forward "** Create Script")
       (org-cut-subtree)
       (search-backward "** Makefile")
       (org-babel-tangle 4)
       (save-buffer 0))'
  printf "${CLEAR}\n"

  if [[ (($# -eq 2) || ($# -eq 3)) && (($2 == 'git') || ($3 == 'git')) ]]
  then
      cd $1 && {
	  rm *~
	  printf "${YELLOWBOLD}"
	  git init
	  printf "${CLEAR}"

	  echo "\
  .gitignore
  Makefile
  ,*~
  .*~
  ,*.texi
  ,*.info
  ,*.html
  ,*-old
  tools" > .gitignore

	  git add .
	  git commit -m "Initial commit of Project $1"
	  git log --stat

      }
  fi

  cd ..
  printf "${PURPLEBOLD}\n"
  pwd
  printf "${CLEAR}"
  tree -aI .git $1

#+end_src
** Update Script						   :env_var:
:PROPERTIES:
:env_var1: (find-file-noselect (getenv "SYNC_ORG_TEMPLATE"))
:END:
This code is a script file to update the Build Tools subtree in a current
project with the updated Build Tools subtree from this template.  It copies the
outline structure of the Build Tools from this template file and yanks it into
the current project’s Org file and delete’s the old, outdated Build Tools
subtree.

Note that there is also a version of this script in the Makefile that is run
from the command line using the ~make update~ command.	This code is an
interactive Elisp function that can be loaded into memory using =C-x C-e= and
then run interactively from within the project Org as =M-x update-build-tools=.

#+caption:Update Build Tools Script
#+name:update-build-tools
#+begin_src emacs-lisp -n
  (defun update-build-tools (of-filenm)
    "Update the Build Tools of the argument file, which should be
  an Org file with a current Build Tools subtree."
    (interactive "ffile: ")
    (require (quote org))
    (save-current-buffer
	(set-buffer
	 (find-file-noselect (getenv "SYNC_ORG_TEMPLATE")))
	(save-excursion
	  (goto-char (point-min))
	  (search-forward "* Build Tools")
	  (org-beginning-of-line)
	  (org-copy-subtree))
	(set-buffer
	 (find-file-noselect of-filenm))
	(save-excursion
	  (goto-char (point-min))
	  (search-forward "* Build Tools")
	  (org-beginning-of-line)
	  (org-yank)
	  (org-cut-subtree)
	  (org-backward-heading-same-level 1)
	  (save-buffer)
	  (org-babel-tangle))))
#+end_src
** Add Readme
This script adds the README.md template to a project.  It should not be
included with the update script because once it becomes associated with a
project, it will be customized, and thus unique to the project.

#+name:add-readme
#+header: :shebang "#!/usb/bin/env bash"
#+begin_src shell
#+end_src

** Switch Emacs Init
This script allows the user to switch into using a different Emacs
initialization setup.  The script first lists the currently-selected
initialization setup, then it lists the available initialization setups, then
requests the user's choice.  After obtaining the choice, it changes the
symbolic link in =~/.emacs.d= to that chosen by the user.  Emacs is then killed
and restarted using the ~desktop-save~ feature.

Each initialization setup is a complete =~/.emacs.d= subtree, which must be set
up by the user, with its name given after a dash, such as =~/.emacs.d-original=
or =~/.emacs.d-cfbt= (“Clojure for the Brave and True”).

#+name:switch-emacs-init
#+header: :mkdirp yes
#+header: :shebang "#!/usr/bin/env bash"
#+header: :tangle /usr/local/dev/bin/switch-emacs-init
#+begin_src sh
  printf "${GREEN}"
  ls -l ~/.emacs.d | cut -f 12- -d ' '
  printf "${CLEAR}"
  echo
  select choice in $(ls -1d ~/.emacs.d-*) "abort"
  do
      echo -n 'You chose '
      printf " ${B_YELLOW}${F_BLACK}$choice${CLEAR}  "
      [[ $choice = "abort" ]] && exit 0
      rm ~/.emacs.d
      printf "${CYAN}"
      ln -vs $choice ~/.emacs.d
      echo
      printf "${RED}"
      read -N 1 -p "Restart Emacs now? (y/n) "
      printf "${CLEAR}\n"
      [[ $REPLY =~ y|Y ]] || { echo "Not restarting"; break; }
      echo "Restarting..."
      emacsclient --eval '(progn (desktop-save "~/.emacs.d-original/")(kill-emacs))'
      break
  done
  /Applications/MacPorts/EmacsMac.app/Contents/MacOS/Emacs --eval '(progn (server-start)(desktop-read "~/.emacs.d-original/"))' &
#+end_src

** Update RC Files
This code synchronizes the following configuration files:
- /etc/profile
- /etc/bashrc
- /etc/tmux.conf
- ~/.bash_profile
- ~/.bashrc
- ~/.tmux.conf


It first verifies that the files differ; then it will copy a newer file over an
older file.  If a  local file is updated with a newer  template file, then this
program updates the  Emacs ~server-socket-dir~ variable, if such  exists.  If a
template   is	updated	  with	 a   newer  local   file,   then   delete   the
~server-socket-dir~ value.

#+name:syncrc
#+header: :mkdirp yes
#+header: :tangle /usr/local/dev/bin/syncrc
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src shell
  [ -v TEMPLATES ] || {
      printf "${RED}ERROR: missing \$TEMPLATES env var${CLEAR}\n"
      exit 1
  }

  [ -v COMP ] || {
      printf "${RED}ERROR: missing \$COMP env var${CLEAR}\n"
      exit 1
  }

  set -e

  ## usage: syncrc [-f system|rc -t rc|system -h]
  ## if no options, process by natural age
  ## if -f and -t options, force update from ... to ...
  usage () {
	printf "\n${GREEN}USAGE: ${YELLOW}syncrc \
  ${WHITEBOLD}[${CYAN}-f ${MAGENTA}system|rc \
  ${CYAN}-t ${MAGENTA}rc|system \
  ${WHITEBOLD}]${CLEAR}\n"

	printf "${GREEN}force sync rc files \
  ${CYAN}'-f'${GREEN}rom ${MAGENTA}system|rc \
  ${CYAN}'-t'${GREEN}o ${MAGENTA}rc|system\
  ${CLEAR}\n\n"
	exit $1
  }

  # force update of either system or rc file
  touchup () {
    printf "In touchup with \$from: $from\n";
	case $from in
	    "system") printf "${WHITEBOLD}Touching $1..."; sudo touch $1; printf "${CLEAR}" ;;
	    "rc")     printf "${WHITEBOLD}Touching $2..."; touch $2; printf "${CLEAR}" ;;
	esac
  }

  # compare files to determine which one is newer
  comp () {
	[[ -e $1 && -e $2 ]] && { # only process if both files exist
	if ! cmp -s $1 $2
	then
	    [[ -n $from ]] && { # force update if $from is non-zero length
		touchup $1 $2
	    } || { :; }
	    [[ $1 -nt $2 ]] && { # system file is newer
		[[ -d $(dirname "$2") ]] || { # make sure rc dir exists
		    mkdir -vp $(dirname "$2")
		} || { :; }

		printf "${YELLOW}system is newer than rc${CLEAR}\n"
		echo; ls -l $1 $2; echo
			  printf "${BLUE}";
			  cp -ipv "$1" "$2";
			  printf "${CLEAR}"

			  ## delete the value of the emacs server-socket-dir in the rc file
			  grep -q "EMACS_SERVER_SOCKET_DIR=" "$2" && {
				  #printf "${WHITE}UNSETTING socket_dir...${CLEAR}\n"
				  sed -i'.bak' -Ee '/(EMACS_SERVER_SOCKET_DIR)=.*$/ s!!\1=TBD!' "$2"
			  } || { :; }

		  } || {
		    [[ "$2" -nt "$1" ]] && { # rc file is newer
		      printf "${YELLOW}rc is newer than system${CLEAR}\n"
		      echo; ls -l $2 $1; echo
		      [[ -w "$1" ]] && { # check if the system file is writable
			printf "${PURPLE}"
			cp -ipv "$2" "$1"
			printf "${CLEAR}"
		      } || {
			printf "${RED}You must authenticate... ${CLEAR}"
			printf "${PURPLE}"
			sudo cp -ipv "$2" "$1"
			printf "${CLEAR}"
		      }

		      ## update the value of the emacs server-socket-dir in the system file
		      grep -q "EMACS_SERVER_SOCKET_DIR=" "$1" && {
			socket_dir=$(${EMACS} -Q --batch --eval '(progn (require (quote server))(princ (file-name-as-directory server-socket-dir)))')
			printf "${WHITE}SETTING socket_dir=${socket_dir}${CLEAR}...\n"
			sed -i'.bak'-$$ -Ee '/(EMACS_SERVER_SOCKET_DIR)=.*$/ s!!\1='"$socket_dir"'!' "$1"
		      } || { :; }

		      } || {
			printf "${REDBOLD}ERROR: the files don't match but are the same age?${CLEAR}\n"
		      }
	      }
	else
	      printf "${CYAN}No difference.${CLEAR}\n"
	fi
	} || {
	    tocreate=$( if test -e "$1"; then echo "$2"; else echo "$1"; fi; )
	    printf "${WHITE}one file: ${RED}${tocreate} ${WHITE}does not exist...Create?${CLEAR}"
	    read -sn 1
	    if [[ $REPLY == [yY] ]]
	    then
		echo " Creating"
		outof=$( if test -e "$1"; then echo $1; else echo "$2"; fi; )
		mkdir -pv $(dirname "${tocreate}")
		cp -ivp "${outof}" "${tocreate}"
	    else
		echo " Not creating"
	    fi
	}
    } # end of comp()

    declare -a rcfiles=(/private/etc/profile /private/etc/bashrc /private/etc/tmux.conf ~/.bash_profile ~/.bashrc ~/.tmux.conf)

    ## see usage() abaove
    while getopts "f:t:h" opt
    do
	  case $opt in
	    'f') from=${OPTARG} ;;
	    't') to=${OPTARG}	;;
	    'h') usage 0	;;
	    '?') printf "${RED}ERROR ${CLEAR}\n"; usage 1; ;;
	     ,*) printf "OPTIND: ${RED}${OPTIND}${CLEAR}\n"; usage 1; ;;
	  esac
    done

    ## OPTIND must be either 1 (no options) or 5 (2 options)
    if [[ $OPTIND -gt 1 && $OPTIND -ne 5 ]]
    then
	  printf "${RED}ERROR: need both -f and -t${CLEAR}\n"
	  usage 1
    fi

    ## check for correct combination of from and to
    if [[ -n $from ]]
    then
	  if [[ $from == "system" ]]
	  then
	    if [[ $to != "rc" ]]
	    then
		printf "${RED}ERROR: incorrect combination: $from -- $to${CLEAR}\n"
		usage 1
	    fi
	  elif [[ $from == "rc" ]]
	  then
	    if [[ $to != "system" ]]
	    then
		printf "${RED}ERROR: incorrect combination: $from -- $to${CLEAR}\n"
		usage 1
	    fi
	  else
	    printf "${RED}ERROR; incorrect combination: $from -- $to${CLEAR}\n"
	    usage 1
	  fi
    fi

    ## everything checks out; now process the files
    for file in "${rcfiles[@]}"
    do
	  printf "Considering ${GREEN}$file... ${CLEAR}"

	  case $file in
	      ,*etc?profile)   comp $file $TEMPLATES/rc/etc/${COMP}/profile   ;;
	      ,*etc?bashrc)    comp $file $TEMPLATES/rc/etc/${COMP}/bashrc    ;;
	      ,*etc?tmux.conf) comp $file $TEMPLATES/rc/etc/${COMP}/tmux.conf ;;
	      ,*bash_profile)  comp $file $TEMPLATES/rc/${COMP}/bash_profile  ;;
	      ,*bashrc)	       comp $file $TEMPLATES/rc/${COMP}/bashrc	      ;;
	      ,*tmux?conf)     comp $file $TEMPLATES/rc/${COMP}/tmux.conf     ;;
	  esac
    done
#+end_src

** Boot Template
:PROPERTIES:
:dependency1: EMACS:=:/Applications/MacPorts/Emacs.app/Contents/MacOS/Emacs or similar
:dependency2: EDITOR:=:emacsclient
:dependency3: =SYNC_ORG_TEMPLATE= defined as $DEV/Templates/Org/Template.org
:END:
Although running the command ~org-babel-tangle~ (=C-c C-v t=) from within Emacs
will install  everything, it would  be nice to have  a simple Makefile  that is
downloaded with this  file that could be  invoked to do the  same thing without
starting Emacs and Org-mode and keying in the ~org-babel-tangle~ command.  This
little Makefile should be stored on  GitHub along with the ~Template.org~ file.
When  the source  is extracted  to a  directory, then  running this  Makefile's
default rule  as simply ~make~  will extract the ~preprocess.el~  script, which
updates  =DEV= and  then  extracts the  full Makefile.   Because  this file  is
tangled along with the full Makefile, it simply gets tacked onto the end of the
big Makefile as an additional rule.   Now, running ~make~ runs the default rule
from the  main Makefile, which is  to extract everything, then  export to TEXI,
INFO, HTML, and PDF forms.

It is assumed that an Emacs server is running, and that the $EDITOR environment
variable is set to use ~emacsclient~.

#+header: :tangle Makefile
#+begin_src makefile
boot:
	$(EDITOR) -u --eval \
		"(with-current-buffer (find-file-noselect \"$(SYNC_ORG_TEMPLATE)\") \
			(goto-char (point-min)) \
			(re-search-forward \"^#[+]name:preprocess.el$$\") \
			(org-babel-tangle (quote (4))) \
			(kill-buffer))"
	./tools/preprocess.el
#+end_src

** Preprocess Env Vars
The environment variable DEV can be in different locations and will be spelled
differently based on how the local machine is set up.  For instance, on one
system, it will be at ~$HOME/Dev~ while in another system it will be at
~/usr/local/dev~.  However, the =:tangle= keyword does not expand variables in
the form ~${DEV}~, but rather requires absolute paths, like ~/usr/local/dev~.
Therefore, this program works like a preprocessor for environment variables set
up as part of =:tangle= lines, changing them to their system environment
variable values prior to tangling.  It lives in the ~tools~ directory.

#+name:preprocess.el
#+header: :mkdirp t
#+header: :tangle tools/preprocess.el
#+header: :shebang "#!/opt/local/bin/emacs --script"
#+begin_src emacs-lisp
  (with-current-buffer (find-file-noselect "Template.org")
    (goto-char (point-min))
    (let ((re-search-str ":tangle \\(.*?/Dev\\)/")
	  (dev (getenv "DEV")))
      (while
	      (re-search-forward re-search-str nil t)
	      (replace-match dev t nil nil 1)))
    (save-buffer)
    (require 'org)
    (org-babel-tangle))
#+end_src

* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:	   cp
:END:

* Program Index
:PROPERTIES:
:index:	   pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:	   fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:	   vr
:unnumbered: t
:END:


* Footnotes


* Configuration							   :noexport:
#+todo: SOMEDAY(s@) TODO(t@) INPROGRESS(i@) WAIT(w@) | CANCEL(c@) DONE(d!)

#+options: H:4

#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:<DIR CATEGORY>
#+texinfo_dir_title:<DIR TITLE>
#+texinfo_dir_desc:<DIR DESCRIPTION>
#+texinfo_printed_title:PRINTED TITLE


* Local Variables						   :noexport:
# Local Variables:
# fill-column: 79
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
